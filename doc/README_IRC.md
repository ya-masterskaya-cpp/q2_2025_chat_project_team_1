# IRC-Chat  
**IRC-подобный мини-чат с комнатами, авторизацией и API на C++**

## Описание проекта  
`IRC-Chat` — чат работает по модели «клиент-сервер» и использует собственный API поверх TCP/IP. Многопоточный сервер принимает соединения от клиентов и обрабатывает сообщения в режиме реального времени. Поддерживается регистрация, авторизация через токен, создание комнат, обмен сообщениями и логгирование.

---

## Функциональность  

### Клиентская часть:
- Графический интерфейс (wxWidgets)
- Выбор сервера из списка (IP:port)
- Подключение к серверу по IP и порту
- Регистрация и вход по имени и паролю (клиент передаёт серверу хэш пароля)
- Хранение пользовательских настроек, включая токен авторизации, в JSON-файле конфигурации
- Восстановление соединения при помощи файла конфигурации
- Просмотр списка доступных комнат
- Создание и выбор комнаты
- Отправка и приём текстовых сообщений
- Автоматическая загрузка истории сообщений при входе в комнату

### Серверная часть:
- Обработка TCP-соединений от клиентов (Boost.Asio)
- Работа в многопоточном режиме
- Сериализация запросов и ответов (Boost.Serialization)
- Обработка заросов клиента: регистрация, вход, создание комнаты, отправка сообщений
- Проверка активных соединений и отключение неактивных клиентов
- Хранение сообщений в PostgreSQL
- Логгирование событий (info, warning, error)

---

## Протокол взаимодействия (TCP)

### Формат сообщений

Каждое сообщение представляет собой сериализованный `unordered_map<string, string>` (через `boost::archive::text_oarchive`).

**КОНЕЦ СООБЩЕНИЯ ОБОЗНАЧАЕТСЯ СИМВОЛОМ `\0`**  
Важно: клиент должен считывать данные из сокета до символа `\0`, а не ожидать длину в заголовке!

**Пример чтения:** `boost::asio::read_until(socket, buffer, '\0')`

### Пример сообщения

До сериализации:
```json
{
  "action": "login",
  "name": "Alice",
  "password": "hashed_pass",
  "roomname": "general"
}
```

После сериализации — строка, заканчивающаяся `\0`.

---

## IRC-Chat API Reference

### Описание клиентских запросов API (Actions)

| Действие         | Параметры                          | Описание                                  |
|------------------|------------------------------------|-------------------------------------------|
| `create_user`    | `name`, `password`                 | Регистрация нового пользователя           |
| `login`          | `name`, `password`, `roomname`     | Вход в систему и подключение к комнате    |
| `create_room`    | `name`                             | Создание новой комнаты                    |
| `room_list`      | (нет параметров)                   | Получение списка комнат                   |
| `get_users`      | `name` (имя комнаты)               | Получение пользователей в комнате         |
| `send_message`   | `token`, `message`                 | Отправка текстового сообщения             |
| `disconnect`     | `token`                            | Отключение от комнаты                     |

### Поля, использующиеся в запросах/ответах (`CONSTANTS::LF_*`)
- `LF_ACTION`: имя действия (action)
- `LF_NAME`: имя пользователя или комнаты
- `LF_PASSWORD`: пароль
- `LF_ROOMNAME`: название комнаты
- `LF_MESSAGE`: текст сообщения
- `LF_TOKEN`: авторизационный токен
- `LF_RESULT`: результат (`success` или `error`)
- `LF_REASON`: описание ошибки
- `LF_USERS`: список пользователей
- `LF_ROOMLIST`: список комнат
- `LF_INITIATOR`: источник ошибки (`server`, `chatroom`)
- `LF_DIRECTION`: направление (`server`, `chatroom`)

### Значения ответов (`CONSTANTS::RF_*`)
- `RF_SUCCESS`: "success"
- `RF_ERROR`: "error"
- `RF_DIRECTION_SERVER`: сообщение направлено на сервер
- `RF_DIRECTION_CHATROOM`: сообщение направлено в чат-комнату
- `RF_ERR_INITIATOR_SERVER`: ошибка произошла на стороне сервера
- `RF_ERR_INITIATOR_CHATROOM`: ошибка произошла на стороне комнаты
- `RF_ERR_PERMISSION_DENIDED`: отказ в доступе

---

## Ответы сервера

### Успешные
```json
{
  "result": "success",
  "action": "send_message"
}
```

### Ошибка
```json
{
  "result": "error",
  "reason": "Invalid password",
  "initiator": "login"
}
```

Все ответы также сериализуются и заканчиваются `\0`.

---

## Архитектура

Общая схема взаимодействия:  
`[Client] <--> [IRC TCP Server] <--> [Другие клиенты]`

### Компоненты

- **IRC TCP Server**  
  Обрабатывает клиентские запросы, управляет подключениями, авторизацией и рассылкой сообщений. Реализован с использованием Boost.Asio и потоков.

- **IRC Chat Database Layer**
  // TODO: дополнить подробным описанием из /doc/README_irc_chat_db.md от Алексея Т
  Реализует слой работы с базой данных для IRC-чата с поддержкой PostgreSQL, пулом соединений, идентификаторами на основе UUID и репозиториями для пользователей, комнат, сообщений и участников комнат.
  Вся бизнес-логика отделена от слоя хранения данных (repository pattern).

- **ChatClient (wxWidgets GUI)**  
  // TODO: дополнить подробным описанием
  Интерфейсный клиент, реализующий подключение, взаимодействие с сервером, отображение сообщений и списков.

---

## Установка

Клонируем репозиторий vcpkg:  
```bash
git clone https://github.com/Microsoft/vcpkg.git ~/.local/share/vcpkg
```

Запускаем bootstrap (для Windows - .\bootstrap-vcpkg.bat):  
```bash
cd ~/.local/share/vcpkg
./bootstrap-vcpkg.sh
```

Убеждаемся VCPKG_ROOT установлен корректо:__
```bash
echo $VCPKG_ROOT
```

Если не установлен, устанавливаем:__
```bash
export VCPKG_ROOT="$HOME/.local/share/vcpkg"
```
(действует только на данную сессию, для постоянной настройки__
добавлем строку в ~/.bashrc или ~/.zshrc)__

Устанавливаем libpqxx, Boost и wxWidgets:__
```bash
vcpkg install libpqxx boost wxwidgets
```

Для специфичных версий (если нужно):__
```bash
vcpkg install libpqxx@7.7.4 boost@1.83.0 wxwidgets@3.2.2.1
```

При проблемах установки смотрим файл `~/.local/share/vcpkg/installed/vcpkg/issue_body.md` 
там все расписано, в частности, каких зависимостей нехватает.__

---

## Сборка проекта

Сборка в директории build (для своей системы поменять путь триплета x64-linux на нужное):__
```bash
cmake .. -DCMAKE_PREFIX_PATH=${VCPKG_ROOT}/installed/x64-linux/share/
cmake --build .

```

---

## Тестирование

Тесты собираются и запускаются в режиме отладочной сборки. Поддерживаются фреймворки Catch2 и GoogleTest.
// TODO: дополнить CMakelist условием сборки тестов только при отладочной сборки

---